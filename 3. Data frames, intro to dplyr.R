install.packages(c("dplyr", "ggplot2", "foreign", "descr", "psych"))

####### Экспорт данных #######


# Чтобы экспортировать таблицу в формате csv функция read.csv()
# НО если сохраняли csv из нашего Excel 
# (тогда в файле будут разделители не "," а ";" и десятые отделены запятой, а не точкой)
# потому можно использовать функцию read.csv2() - там эти аттрибуты по умолчанию
data_csv <- read.csv2("data.csv", encoding = "UTF-8")
head(data_csv)

# Чтоюы экспортировать массив из SPSS - пакет "foreign"
library(foreign)

# Обычно проблема возникает с перекодировкой :((
data_spss <- read.spss("data.sav", to.data.frame = TRUE, reencode = TRUE)
head(data_spss)

# Потому будем использовать csv 
# Для начала переименуем для удобства
dat <- data_csv

str(dat)

# Удалим все лишние переменные и переименуем для удобства
# Сначала покажу прием, которым пользоваться ни в коем случае нельзя!))
fix(dat)
# Так можно править таблицу - например, переименовывать названия переменных...
# Но не забывайте, что фишка кода в том, что все изменения можно повторить
# Потому не будьте читерами))

# А вот так делать правильнее:
names(dat)[1] <- "Id"

# Удаляем ненужные переменные

# Проверяем результат
str(dat)
summary(dat)


# Одно из правил чистого массива - перекодирование номинальных переменных в факторы
# Это можно сделать так:
class(dat$sex)
summary(dat$sex)

dat$sex[dat$sex==1] <- "man"
dat$sex[dat$sex==2] <- "woman"
dat$sex <- as.factor(dat$sex)

# проверяем себя
summary(dat$sex)


##### Исследуем переменные таблицы ##### 
# Базовое:
summary(dat$age)

# Но иногда хочется больше "плюшек" в одну строчку:
library(psych)
describe(dat$age, IQR = T)


##### Двумерные таблицы: ##### 

## 1 базовый вариант
table(dat$sex) # напоминаю - так смотрим одномерное распределение

table(dat$G1, dat$sex) # а вот так уже двумерное

table(dat$G1, dat$G6, dat$sex) # можно даже так - набор двумерных по третьему признаку
# Но выглядят эти таблицы ужасно)))


## 2 улучшенный вариант
library(descr)

# не забываем определить, что % считаем по независимой переменной (всегда в столбике)!!!
crosstab(dat$G1, dat$sex, 
         prop.r = F, prop.c = T)
# Как вы заметили, эта функция даже плот выводит


#### Проверьте себя ####
# 1. Посмотрите есть ли разница между мужчинами и женщинами по вопросу G4
# 2. А для людей с разным экономическим состоянием (D8)?
# 3. Определите границы 6 возрастных групп (age_6gr)
# 4. Превратите переменную age_6gr в факторную чтобы было удобнее с ней работать
# 5. Есть ли разница ответов по переменной G1 для разных возрастных групп




####### Работа с таблицами - прелести dplyr ########

library(dplyr)

# Это, конечно, прекрасно когда у нас есть готовый чистый массив, 
# но, увы, это скорее редкость...
# Потому для упрощения вашей жизни создали dplyr

# dplyr = grammar of data manipulation

# Будем работать со стандартными данными в R
?airquality

dat2 <- airquality
str(dat2)
summary(dat2)
head(dat2)

dat2

# Работает с типом данных tbl ("tibble)
# потому сначала превращаем данные в этот тип
dat2 <- tbl_df(dat2)

dat2 # обратите внимание на отображение таблицы

# Если захотите вернуть обратно к data.frame
class(as.data.frame(dat2))

# С tbl можно делать все то же самое что и с data.frame
# и еще намного больше:

unique(dat2$Day) # посмотреть все варианты ответа

# Есть 5 основополагающих функций dplyr:
# 1. select()     - отбираем колонки
# 2. filter()     - отбираем строки
# 3. arrange()    - упорядочивает массив
# 4. mutate()     - создает новую колонку на основе других (например, сумма)
# 5. summarize()  - считает основные статистики



###### 1. select() #######
# работает с переменными
# принцип работы: select(data frame, columns to select)

select(dat2,Temp, Month)
table(select(dat2,Temp, Month))

# можно использовать номера столбцов
select(dat2, 2,3)

# можно выбирать колонки через запятую, двоеточие и исключить -(x,y)
select(dat2, -(Day))



###### Функции для работы с переменными ######
?select_helpers

# starts_with("x") - начинающиеся на "x"
# end_with("x") - заканчивающиеся на "x"
# contains("x") - содержит "x"
# num_range("x", 1:5) - переменные x01, x02, x03, x04, x05
# one_of(x) - где х - вектор со значениями

# Примеры:
iris <- tbl_df(iris) # еще один стандартный массив
iris
str(iris)

select(iris, starts_with("Petal"))
select(iris, ends_with("Width"))
select(iris, contains("etal"))
select(iris, Petal.Length, Petal.Width)

vars <- c("Petal.Length", "Petal.Width")
select(iris, one_of(vars))

